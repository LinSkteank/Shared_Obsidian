Вертикальные margin у соседних элементов объединяются между собой, что известно под термином «схлопывающиеся margin». Само схлопывание действует на два соседних блока или родительский и дочерний блоки, при этом примыкающие отступы не суммируются, а комбинируются в один.

__Для margin слева и справа схлопывание никогда не применяется.__

### Схлопывание margin у соседних элементов
Схлопывание задумывалось в первую очередь для корректного отображения текста в абзацах. Расстояние между абзацами <p> без схлопывания увеличится в два раза, тогда как верхний margin у первого абзаца и нижний margin у последнего абзаца останутся неизменными. Схлопывание гарантирует, что расстояние в абзацах везде будет одинаковым.

В примере два блока располагаются один под другим, при этом у первого блока отступ снизу равен 20px, а у второго блока отступ сверху равен 10px.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .block {
    padding: 20px; /* Поля вокруг текста */
    border: 1px solid #666; /* Параметры рамки */
   }
   .block1 {
    background: #E2EDC1; /* Цвет фона первого блока */
    margin-bottom: 20px; /* Отступ снизу */
   }
   .block2 {
    background: #FCE3EE; /* Цвет фона второго блока */
    margin-top: 10px; /* Отступ сверху */
   }
  </style>
 </head>
 <body>
  <div class="block block1">Первый блок</div>
  <div class="block block2">Второй блок</div>
 </body>
</html>
```

_Если оба значения margin положительные, то из них выбирается наибольшее значение и оно задаётся как расстояние между блоков._

На рисунке приведено схематическое изображение результата схлопывания margin.

![[margin-collapse2.png]]

Если один из margin отрицательный, то в этом случае происходит их складывание по правилам математики:

```
x + (-y) = x – y
```

_Если один из margin отрицательный, тогда margin вычитаются._

На рисунке схематично приведено поведение блоков, когда верхний margin у нижнего блока отрицательный.

![[margin-collapse3.png]]

Если полученное значение в результате суммирования окажется отрицательным, то оно будет действовать на нижний блок, соответственно, он сдвинется вверх на указанное значение. При этом возможно наложение одного блока на другой.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .block {
    padding: 20px; /* Поля вокруг текста */
    border: 1px solid #666; /* Параметры рамки */
   }
   .block1 {
    background: #E2EDC1; /* Цвет фона первого блока */
    margin-bottom: 20px; /* Отступ снизу */
   }
   .block2 {
    background: #FCE3EE; /* Цвет фона второго блока */
    margin-top: -10px; /* Отрицательный отступ сверху */
   }
  </style>
 </head>
 <body>
  <div class="block block1">Первый блок</div>
  <div class="block block2">Второй блок</div>
 </body>
</html>
```

_Если оба margin отрицательные, то из двух значений выбирается наибольшее по модулю, оно же и выступает в качестве отрицательного отступа между элементами._

Так, если отступы равны -10px и -20px, то итоговое значение будет -20px. При этом элементы будут частично перекрываться.

![[margin-collapse5.png]]

### Пустые элементы

Для пустых элементов, внутри которых нет никакого содержимого, margin-top и margin-bottom также комбинируются в один по тем же правилам, что и для соседних блоков. При этом должен ещё соблюдаться ряд условий:

-   для элемента не должен быть задан padding сверху или снизу;
-   для элемента не должен быть задан border сверху или снизу;
-   высота элемента не должна быть указана через свойство _height_ или _min-height_.

Одновременное сочетание всех этих условий (нет содержимого, не указана высота, padding и border) встречается довольно редко, так что многие веб-разработчики никогда и не сталкиваются с подобным поведением.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .hollow {
    margin-top: 20px; /* Отступ сверху */
    margin-bottom: 20px; /* Отступ снизу */
   }
   .block {
    padding: 20px; /* Поля вокруг текста */
    border: 1px solid #666; /* Параметры рамки */
   }
   .block1 {
    background: #E2EDC1; /* Цвет фона первого блока */
   }
   .block2 {
    background: #FCE3EE; /* Цвет фона второго блока */
   } 
  </style>
 </head>
 <body>
  <div class="block block1">Первый блок</div>
  <div class="hollow"></div>
  <div class="block block2">Второй блок</div>
 </body>
</html>
```

### Вложенные элементы

Также схлопываются margin самого блока с margin у его первого и последнего дочерними элементами. Более точно комбинируется так:

-   margin-top родителя с margin-top его первого дочернего элемента;
-   margin-bottom родителя с margin-bottom его последнего дочернего элемента.

На рисунке схематично показано что margin у дочернего элемента располагается не внутри родителя, а выходит за его пределы.

![[margin-collapse7.png]]

Такое поведение часто можно встретить у заголовков, вроде `<h1>` или `<h2>`, которые идут первыми в блоке. У этих заголовков уже содержится margin-top и margin-bottom по умолчанию и он, объединяясь с родительским margin, влияет на отступы всего блока.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .block {
    background: #FCE3EE; /* Цвет фона блока */
   }
   h1 {
    background: #E2EDC1; /* Цвет фона заголовка */
   } 
  </style>
 </head>
 <body>
  <div class="block">
   <h1>Заголовок</h1>
  </div>
  <p>Текст снизу</p>
 </body>
</html>
```

### Отмена схлопывания margin

Схлопывание не всегда требуется при вёрстке страницы, а в некоторых случаях вообще «ломает» дизайн. Поэтому следует знать, в каких случаях схлопывание не работает.

Схлопывание margin не срабатывает:

-   для элементов с абсолютным позиционированием, т. е. таких, у которых _position_ установлено как absolute или fixed;
-   для обтекаемых элементов (для них свойство _float_ задано как left или right);
-   для строчных или строчно-блочных элементов (для них свойство [[display]] задано как inline или inline-block);
-   для флекс-элементов (у родителя которых свойство display задано как flex или inline-flex);
-   для элемента `<html>`.

Схлопывание не действует на дочерние элементы:

-   если у родителя значение [[overflow]] задано как auto, hidden или scroll;
-   если у родителя на стороне схлопывания задано свойство [[2) padding]];
-   если у родителя на стороне схлопывания задано свойство [[3) border]].

Учтите, что свойства padding и border должны иметь размер больше нуля, к примеру, 1px.

Возьмём пример и доработаем его, чтобы margin у заголовка работал внутри блока. Для этого к родительскому блоку добавляем свойство padding со значением 0.1px. На экране такая величина будет незаметна, но браузеры её понимают и схлопывание margin отменяют.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .block {
    background: #FCE3EE; /* Цвет фона блока */
    padding: 0.1px 0; /* Отменяем схлопывание */
   }
   h1 {
    background: #E2EDC1; /* Цвет фона заголовка */
   } 
  </style>
 </head>
 <body>
  <div class="block">
   <h1>Заголовок</h1>
  </div>
  <p>Текст снизу</p>
 </body>
</html>
```

Для отмены схлопывания у дочерних элементов можно использовать один из вариантов.

```css
.block {
  /* 1. Ненулевой padding сверху и снизу */ 
  padding: 0.1px 0;
  /* 2. Скрываем всё за пределами блока */ 
  overflow: hidden;
  /* 3. Прозрачная линия сверху и снизу */
  border-top: 1px solid transparent; 
  border-bottom: 1px solid transparent;
}
```

Для соседних элементов схлопывание margin отменять, как правило, нет необходимости, поскольку результат достаточно предсказуем — надо только помнить о поведении margin или включать margin-top или margin-bottom лишь для одного элемента. В примере ниже расстояние между блоков регулируется значением margin-bottom у block1. Здесь этот margin единственный, поэтому никакого объединения не происходит и вертикальный промежуток между блоков равен значению margin-bottom.

```html
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>margin</title>
  <style>
   .block {
    padding: 20px; /* Поля вокруг текста */
    border: 1px solid #666; /* Параметры рамки */
   }
   .block1 {
    background: #E2EDC1; /* Цвет фона первого блока */
    margin-bottom: 30px; /* Отступ снизу */
   }
   .block2 {
    background: #FCE3EE; /* Цвет фона второго блока */
   }
  </style>
 </head>
 <body>
  <div class="block block1">Первый блок</div>
  <div class="block block2">Второй блок</div>
 </body>
</html>
```

Для полноты картины приведём несколько вариантов, когда схлопывание margin у соседних блоков не работает. Данный стиль можно добавить к каждому блоку или только к одному. Ширина элемента с float определяется содержимым элемента, поэтому надо явно задать ширину блока, равную 100%. За счёт этого не ломается вёрстка, потому что нет места для обтекания элемента.

```css
/* 1. Использование float */
.block {
  float: left; /* Обтекаемый элемент */
  width: 100%; /* Занимает всю доступную ширину */
  box-sizing: border-box; /* Ширина не учитывает padding и border */
}
```

Ширина строчно-блочных элементов также определяется их содержимым, поэтому данный вариант похож на предыдущий.

```css
/* 2. Использование строчно-блочных элементов */
.block {
  display: inline-block; /* Строчно-блочный элемент */
  width: 100%; /* Занимает всю доступную ширину */
  box-sizing: border-box; /* Ширина не учитывает padding и border */
}
```

Класс parent надо добавить к родителю наших блоков.

```css
/* 3. Использование флексбоксов */
.parent {
  display: flex; /* Работаем с флексами */
  flex-direction: column; /* Элементы выводятся друг под другом */
}
```

