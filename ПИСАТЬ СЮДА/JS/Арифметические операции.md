### Термины: «унарный», «бинарный», «операнд»
_Операнд_ – то, к чему применяется оператор. Например, в умножении `5 * 2` есть два операнда: левый операнд равен `5`, а правый операнд равен `2`. Иногда их называют «аргументами» вместо «операндов».

_Унарным_ называется оператор, который применяется к одному операнду. Например, оператор унарный минус `"-"` меняет знак числа на противоположный:
```javascript
let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус
```

_Бинарным_ называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
```javascript
let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения
```

Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).

Поддерживаются следующие математические операторы:

-   Сложение `+`,
-   Вычитание `-`,
-   Умножение `*`,
-   Деление `/`,
-   Взятие остатка от деления `%`,
-   Возведение в степень `**`.

### Сложение строк при помощи бинарного +
Eсли бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:
```javascript
let s = "моя" + "строка";
alert(s); // моястрока
```

Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
```javascript
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Как видите, не важно, первый или второй операнд является строкой.
```javascript
alert(2 + 2 + '1' ); // будет "41", а не "221"
```

Сложение и преобразование строк — это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

Например, вычитание и деление:
```javascript
alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам
```

### Приведение к числу, унарный +

Плюс `+` существует в двух формах: бинарной, которую мы использовали выше, и унарной.

Унарный, то есть применённый к одному значению, плюс `+` ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.
```javascript
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
```

На самом деле это то же самое, что и `Number(...)`, только короче.

Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

Бинарный плюс сложит их как строки:
```javascript
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
```

Поэтому используем унарный плюс, чтобы преобразовать к числу:

```javascript
let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

### Приоритет операторов

<table>
	<thead>
		<tr>
			<th>Precedence</th>
			<th>Operator type</th>
			<th>Associativity</th>
			<th>Individual operators</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>member</td>
			<td>left-to-right</td>
			<td>. []</td>
		</tr>
		<tr>
			<td>1</td>
			<td>new</td>
			<td>right-to-left</td>
			<td>new</td>
		</tr>
		<tr>
			<td>2</td>
			<td>function call</td>
			<td>left-to-right</td>
			<td>()</td>
		</tr>
		<tr>
			<td>3</td>
			<td>increment</td>
			<td>n/a</td>
			<td>++</td>
		</tr>
		<tr>
			<td>3</td>
			<td>decrement</td>
			<td>n/a</td>
			<td>--</td>
		</tr>
		<tr>
			<td>4</td>
			<td>logical-not</td>
			<td>right-to-left</td>
			<td>!</td>
		</tr>
		<tr>
			<td>4</td>
			<td>bitwise not</td>
			<td>right-to-left</td>
			<td>~</td>
		</tr>
		<tr>
			<td>4</td>
			<td>unary +</td>
			<td>right-to-left</td>
			<td>+</td>
		</tr>
		<tr>
			<td>4</td>
			<td>unary negation</td>
			<td>right-to-left</td>
			<td>-</td>
		</tr>
		<tr>
			<td>4</td>
			<td>typeof</td>
			<td>right-to-left</td>
			<td>typeof</td>
		</tr>
		<tr>
			<td>4</td>
			<td>void</td>
			<td>right-to-left</td>
			<td>void</td>
		</tr>
		<tr>
			<td>4</td>
			<td>delete</td>
			<td>right-to-left</td>
			<td>delete</td>
		</tr>
		<tr>
			<td>5</td>
			<td>multiplication</td>
			<td>left-to-right</td>
			<td>*</td>
		</tr>
		<tr>
			<td>5</td>
			<td>division</td>
			<td>left-to-right</td>
			<td>/</td>
		</tr>
		<tr>
			<td>5</td>
			<td>modulus</td>
			<td>left-to-right</td>
			<td>%</td>
		</tr>
		<tr>
			<td>6</td>
			<td>addition</td>
			<td>left-to-right</td>
			<td>+</td>
		</tr>
		<tr>
			<td>6</td>
			<td>subtraction</td>
			<td>left-to-right</td>
			<td>-</td>
		</tr>
		<tr>
			<td>7</td>
			<td>bitwise shift</td>
			<td>left-to-right</td>
		<td>&amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;</td>
		</tr>
		<tr>
			<td>8</td>
			<td>relational</td>
			<td>left-to-right</td>
		<td>&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=</td>
		</tr>
		<tr>
			<td>8</td>
			<td>in</td>
			<td>left-to-right</td>
			<td>in</td>
		</tr>
		<tr>
			<td>8</td>
			<td>instanceof</td>
			<td>left-to-right</td>
			<td>instanceof</td>
		</tr>
		<tr>
			<td>9</td>
			<td>equality</td>
			<td>left-to-right</td>
			<td>== != === !==</td>
		</tr>
		<tr>
			<td>10</td>
			<td>bitwise-and</td>
			<td>left-to-right</td>
			<td>&amp;amp;</td>
		</tr>
		<tr>
			<td>11</td>
			<td>bitwise-xor</td>
			<td>left-to-right</td>
			<td>^</td>
		</tr>
		<tr>
			<td>12</td>
			<td>bitwise-or</td>
			<td>left-to-right</td>
			<td>I</td>
		</tr>
		<tr>
			<td>13</td>
			<td>logical-and</td>
			<td>left-to-right</td>
			<td>&amp;amp;&amp;amp;</td>
		</tr>
		<tr>
			<td>14</td>
			<td>logical-or</td>
			<td>left-to-right</td>
			<td>II</td>
		</tr>
		<tr>
			<td>15</td>
			<td>conditional</td>
			<td>right-to-left</td>
			<td>?:</td>
		</tr>
		<tr>
			<td>16</td>
			<td>yield</td>
			<td>right-to-left</td>
			<td>yield</td>
		</tr>
		<tr>
			<td>17</td>
			<td>assignment</td>
			<td>right-to-left</td>
			<td>= += -= *= /= %= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;gt;&amp;gt;&amp;gt;= &amp;amp;= ^= I=</td>
		</tr>
		<tr>
			<td>18</td>
			<td>comma</td>
			<td>left-to-right</td>
			<td>,</td>
		</tr>
	</tbody>
</table>

### Присваивание
Когда переменной что-либо присваивают, например, `x = 2 * 2 + 1`, то сначала выполнится арифметика, а уже затем произойдёт присваивание `=` с сохранением результата в `x`.
```javascript
let x = 2 * 2 + 1;

alert( x ); // 5
```

Вызов `x = value` записывает `value` в `x` _и возвращает его_.

Благодаря этому присваивание можно использовать как часть более сложного выражения:
```javascript
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

#### Присваивание по цепочке
Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение `2 + 2`, и затем результат присваивается переменным слева: `c`, `b` и `a`. В конце у всех переменных будет одно значение.
```javascript
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:
```javascript
c = 2 + 2;
b = c;
a = c;
```

#### Сокращённая арифметика с присваиванием
Часто нужно применить оператор к переменной и сохранить результат в ней же.
```javascript
let n = 2;
n = n + 5;
n = n * 2;
```

Эту запись можно укоротить при помощи совмещённых операторов `+=` и `*=`:
```javascript
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)

alert( n ); // 14
```

Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: `/=`, `-=` и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:
```javascript
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)
```

### Инкремент/декремент
Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:

1) **Инкремент** `++` увеличивает переменную на 1:
```javascript
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
alert( counter ); // 3
```

2) **Декремент** `--` уменьшает переменную на 1:
```javascript
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
alert( counter ); // 1
```

__Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.__

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

-   Когда оператор идёт после переменной — это «постфиксная форма»: `counter++`.
-   «Префиксная форма» — это когда оператор идёт перед переменной: `++counter`.

Обе эти инструкции делают одно и то же: увеличивают `counter` на `1`.

Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

Чтобы увидеть разницу, вот небольшой пример:
```javascript
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

В строке `(*)` _префиксная_ форма `++counter` увеличивает `counter` и возвращает новое значение `2`. Так что `alert` покажет `2`.

Теперь посмотрим на постфиксную форму:
```javascript
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
```

- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
 ```javascript
let counter = 0;
counter++;
++counter;
alert( counter ); // 2, обе строки сделали одно и то же
```

- Если хочется тут же использовать результат, то нужна префиксная форма:
```javascript
let counter = 0;
alert( ++counter ); // 1
```

- Если нужно увеличить и при этом получить значение переменной _до увеличения_ – нужна постфиксная форма:
```javascript
let counter = 0;
alert( counter++ ); // 0
```

### Побитовые операторы
Поддерживаются следующие побитовые операторы:

-   AND(и) ( `&` )
-   OR(или) ( `|` )
-   XOR(побитовое исключающее или) ( `^` )
-   NOT(не) ( `~` )
-   LEFT SHIFT(левый сдвиг) ( `<<` )
-   RIGHT SHIFT(правый сдвиг) ( `>>` )
-   ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )

Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне.

### Оператор «запятая»
Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего.
```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат вычисления 3 + 4)
```

